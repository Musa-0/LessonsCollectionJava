package com.test.threading;

public class VolatileEx extends Thread{
            volatile boolean b = true;//тут дана переменная. которая равна тру, она нужна для того чтобы остановить наш цикл
            //volatile - позволит этой переменной хранить значение лишь в ОЗУ и не записывать в кеш

    @Override
    public void run() {
        long counter = 0;
        while (b){//если b станет равным false то цикл закончится
            counter++;
        }
        System.out.println("Цикл закончен "+ counter);
    }

    public static void main(String[] args) throws InterruptedException {
        VolatileEx thread = new VolatileEx();
        thread.start();
        Thread.sleep(3000);//ждем три секунды
        System.out.println("Wake UUP");


        thread.b = false;//ПЕРЕДАЕМ b ЗНАЧЕНИЕ FALSE ТЕМ САМЫМ ОСТАНАВЛИВАЕМ ЦИКЛ ТОТ ЧТО В МЕТОДЕ RUN НО ЭТО НЕ ПРОИЗОЙДЕТ
        //АХАХАХА ПОТОМУ ЧТО переменная b хранится в памяти это да. но потоки, для ускорения работы записывают её значение
        //в регистр процессора. тем самым при смене значения b в одном из потоке, значение b поменяется лишь в кеше этого потока
        //а в памяти b так и будет равна true, так же и в кеше второго потока, b не изменится и цикл тупо не остановится
        //чтобы переменная не записывалась в кэш а бралась на прямую из памяти надо использовать volatile

        //но есть одно но! переменную типа volatile может менять лишь один поток, остальные же могут его лишь читать
        //это желательная рекомендация, ибо тогда может возникнуть коллизия когда два потока будут менять переменную, и в один
        //момень один поток прервет действие второго на середине


        thread.join();//ожидаем окончание потока
        System.out.println("Программа окончена");
    }
}
